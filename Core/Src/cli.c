/*
 * cli.c
 *
 *  Created on: Jul 17, 2024
 *      Author: Yoann Hervagault
 */
#include "cli.h"

//inspired from https://www.edwinfairchild.com/p/making-freertos-cli-more-cli-ish-minor.html

#define MAX_INPUT_LENGTH 50
#define MAX_OUTPUT_LENGTH 512

/* CLI escape sequences*/
uint8_t backspace[] = "\x08 \x08";
uint8_t cRxedChar = 0x00;
extern uint8_t song;
extern WS2813_HandlerTypeDef ledhandler;
extern ts_servo servo;

void vCommandConsoleTask(void *pvParameters)
{
    int8_t cInputIndex = 0;
    BaseType_t xMoreDataToFollow;
    /* The input and output buffers are declared static to keep them off the
     * stack. */
    static int8_t pcOutputString[MAX_OUTPUT_LENGTH], pcInputString[MAX_INPUT_LENGTH];
    HAL_UART_Receive_IT(&huart2, &cRxedChar, 1);
    vRegisterCLICommands();
    //vRegisterFileSystemCLICommands();

    for (;;)
    {

        if (cRxedChar != 0x00)
        {

            if (cRxedChar == '\r' || cRxedChar == '\n')
            {
                printf("\r\n");
                fflush(stdout);
                /* A newline character was received, so the input command string is
                complete and can be processed.  Transmit a line separator, just to
                make the output easier to read. */

                /* The command interpreter is called repeatedly until it returns
                pdFALSE.  See the "Implementing a command" documentation for an
                exaplanation of why this is. */
                do
                {
                    /* Send the command string to the command interpreter.  Any
                    output generated by the command interpreter will be placed in the
                    pcOutputString buffer. */
                    xMoreDataToFollow =
                        FreeRTOS_CLIProcessCommand(pcInputString,    /* The command string.*/
                                                   pcOutputString,   /* The output buffer. */
                                                   MAX_OUTPUT_LENGTH /* The size of the output buffer. */
                        );

                    /* Write the output generated by the command interpreter to the
                    console. */

                    for (int x = 0; x < (xMoreDataToFollow == pdTRUE ? MAX_OUTPUT_LENGTH : strlen(pcOutputString)); x++)
                    {
                        printf("%c", *(pcOutputString + x));
                        fflush(stdout);
                    }

                } while (xMoreDataToFollow != pdFALSE);

                /* All the strings generated by the input command have been sent.
                Processing of the command is complete.  Clear the input string ready
                to receive the next command. */
                cInputIndex = 0;
                memset(pcInputString, 0x00, MAX_INPUT_LENGTH);
                memset(pcOutputString, 0x00, MAX_INPUT_LENGTH);
            }
            else
            {
                /* The if() clause performs the processing after a newline character
                is received.  This else clause performs the processing if any other
                character is received. */

                if (cRxedChar == '\b')
                {
                    /* Backspace was pressed.  Erase the last character in the input
                    buffer - if there are any. */
                    if (cInputIndex > 0)
                    {
                        cInputIndex--;
                        memset(&pcInputString[cInputIndex], 0x00, 1);
                        printf("%s", (const uint8_t *)  pcInputString);
                    }
                    fflush(stdout);
                }
                else
                {
                    /* A character was entered.  It was not a new line, backspace
                    or carriage return, so it is accepted as part of the input and
                    placed into the input buffer.  When a n is entered the complete
                    string will be passed to the command interpreter. */
                    if (cInputIndex < MAX_INPUT_LENGTH)
                    {
                        pcInputString[cInputIndex] = cRxedChar;
                        cInputIndex++;
                        printf("%c", cRxedChar);
                    }
                }
            }
            cRxedChar = 0x00;
            fflush(stdout);
        }
        osDelay(1);
    }
}

/******************************************************************************************************/
static BaseType_t cmd_ok(int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString);

static BaseType_t cmd_ok(int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString)
{
    const char *const okMessage = "everything OK! \r\n";

    memset(pcWriteBuffer, 0x00, xWriteBufferLen);
    strcpy(pcWriteBuffer, okMessage);
    /* There is no more data to return after this single string, so return
        pdFALSE. */
    return pdFALSE;
}

static const CLI_Command_Definition_t xCmdOK = {
    "ok",                               // command to type
    "ok :\r\n Shows an OK message\r\n", // help string
    cmd_ok,                             // command handler
    0                                   // num of pasrameters to expect
};
/******************************************************************************************************/
/******************************************************************************************************/
static BaseType_t cmd_led(int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString);

static BaseType_t cmd_led(int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString)
{
	char *pcParameter1;
	BaseType_t xParameter1StringLength, xResult;
	memset(pcWriteBuffer, 0x00, xWriteBufferLen);

	pcParameter1 = FreeRTOS_CLIGetParameter
	                        (
	                          /* The command string itself. */
	                          pcCommandString,
	                          /* Return the first parameter. */
	                          1,
	                          /* Store the parameter string length. */
	                          &xParameter1StringLength
	                        );
	pcParameter1[ xParameter1StringLength ] = 0x00;
	if(strcmp(pcParameter1, "red")==0)
	{
		WS2813_eSetColor(&ledhandler,WS2813Red,0);
		strcat(pcWriteBuffer, ">>led RED\r\n");
	}
	else if (strcmp(pcParameter1, "blue")==0)
	{
		WS2813_eSetColor(&ledhandler,WS2813Blue,0);
		strcat(pcWriteBuffer, ">>led BLUE\r\n");
	}
	else if (strcmp(pcParameter1, "green")==0)
	{
		WS2813_eSetColor(&ledhandler,WS2813Green,0);
		strcat(pcWriteBuffer, ">>led GREEN\r\n");
	}
	else if (strcmp(pcParameter1, "cyan")==0)
	{
		WS2813_eSetColor(&ledhandler,WS2813Cyan,0);
		strcat(pcWriteBuffer, ">>led CYAN\r\n");
	}
	else if (strcmp(pcParameter1, "purple")==0)
	{
		WS2813_eSetColor(&ledhandler,WS2813Purple,0);
		strcat(pcWriteBuffer, ">>led PURPLE\r\n");
	}
	else if (strcmp(pcParameter1, "yellow")==0)
	{
		WS2813_eSetColor(&ledhandler,WS2813Yellow,0);
		strcat(pcWriteBuffer, ">>led YELLOW\r\n");
	}
	else if (strcmp(pcParameter1, "orange")==0)
	{
		WS2813_eSetColor(&ledhandler,WS2813Orange,0);
		strcat(pcWriteBuffer, ">>led ORANGE\r\n");
	}
	else if (strcmp(pcParameter1, "off")==0)
	{
		WS2813_eSetColor(&ledhandler,WS2813Off,0);
		strcat(pcWriteBuffer, ">>led OFF\r\n");
	}
	else
	{
		strcat(pcWriteBuffer, ">>arg not valid\r\n");
	}

    return pdFALSE;
}

static const CLI_Command_Definition_t xCmdLed = {
    "led",                               // command to type
    "led :\r\n <color>: red, blue, green...\r\n", // help string
	cmd_led,                             // command handler
    1                                   // num of pasrameters to expect
};
/******************************************************************************************************/
//servo
static BaseType_t CmdServo( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString );

static BaseType_t CmdServo( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
{
	char *pcParameter1;
	const char const buff[30];
		const char const okMessage[20];
		BaseType_t xParameter1StringLength, xResult;
		memset(pcWriteBuffer, 0x00, xWriteBufferLen);

		pcParameter1 = FreeRTOS_CLIGetParameter
		                        (
		                          /* The command string itself. */
		                          pcCommandString,
		                          /* Return the first parameter. */
		                          1,
		                          /* Store the parameter string length. */
		                          &xParameter1StringLength
		                        );
		pcParameter1[ xParameter1StringLength ] = 0x00;
		uint8_t u8cons = atoi(pcParameter1);
		if(u8cons>180)
		{
			strcat(pcWriteBuffer,"parameter error\r\n");
			return(pdFALSE);
		}
		//servoMng_SetAngle((float)u8cons);
		servo_SetAngle(&servo,(float)u8cons);
		sprintf(buff, ">>Servo angle set to %u\r\n",u8cons);
		strcat(pcWriteBuffer,buff);
		return(pdFALSE);
}
static const CLI_Command_Definition_t xCmdServo = {
    "servo",                               // command to type
    "servo :\r\n <angle>: [0:180]\r\n", // help string
	CmdServo,                             // command handler
    1                                   // num of pasrameters to expect
};
/******************************************************************************************************/
/******************************************************************************************************/
//buzzer
static BaseType_t cmd_buzzer(int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString);

static BaseType_t cmd_buzzer(int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString)
{
	char *pcParameter1;
	const char const okMessage[20];
	BaseType_t xParameter1StringLength, xResult;

	pcParameter1 = FreeRTOS_CLIGetParameter
	                        (
	                          /* The command string itself. */
	                          pcCommandString,
	                          /* Return the first parameter. */
	                          1,
	                          /* Store the parameter string length. */
	                          &xParameter1StringLength
	                        );
	pcParameter1[ xParameter1StringLength ] = 0x00;
	if(strcmp(pcParameter1, "zelda")==0)
	{
		//send request play zelda
		song = zelda_theme;
		//osMessageQueuePut(SongsQueueHandle, &song, NULL, 0);
		memcpy(okMessage, ">>play ZELDA\r\n", 15);
	}
	else if (strcmp(pcParameter1, "mario")==0)
	{
		//send request play mario
		song =  mario_theme;
		//osMessageQueuePut(SongsQueueHandle, &song, NULL, 0);
		memcpy(okMessage, ">>play MARIO\r\n", 14);
	}
	else if (strcmp(pcParameter1, "pokemon")==0)
	{
		//send request play mario
		song =  pokemon_battletheme;
		//osMessageQueuePut(SongsQueueHandle, &song, NULL, 0);
		memcpy(okMessage, ">>play Pokemon\r\n", 16);
	}
	else if (strcmp(pcParameter1, "off")==0)
	{
		//send request play mario
		song = theme_nb;
		//osMessageQueuePut(SongsQueueHandle, &song, NULL, 0);
		memcpy(okMessage, ">>stop playing! \r\n", 16);
	}
	else
	{
		memcpy(okMessage, ">>arg not valid\r\n", 17);
	}


	memset(pcWriteBuffer, 0x00, xWriteBufferLen);
	strcpy(pcWriteBuffer, okMessage);
    return pdFALSE;
}

static const CLI_Command_Definition_t xCmdBuzzer = {
    "buzzer",                               // command to type
    "buzzer :\r\n <song>: zelda, mario\r\n", // help string
	cmd_buzzer,                             // command handler
    1                                   // num of pasrameters to expect
};
/******************************************************************************************************/
/******************************************************************************************************/
//set clock

static BaseType_t CmdClock( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString );

static BaseType_t CmdClock( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
{
	char *pcParameter1;
	char *pcParameter2;
	BaseType_t xParameter1StringLength, xParameter2StringLength, xResult;
	const char const buff[30];
	memset(pcWriteBuffer, 0x00, xWriteBufferLen);

	pcParameter2 = ( char * )FreeRTOS_CLIGetParameter
	                        (
	                          /* The command string itself. */
	                          pcCommandString,
	                          /* Return the 2nd parameter. */
	                          2,
	                          /* Store the parameter string length. */
	                          &xParameter2StringLength
	                        );
	pcParameter2[ xParameter2StringLength ] = 0x00;

	pcParameter1 = ( char * )FreeRTOS_CLIGetParameter
	                        (
	                          /* The command string itself. */
	                          pcCommandString,
	                          /* Return the first parameter. */
	                          1,
	                          /* Store the parameter string length. */
	                          &xParameter1StringLength
	                        );
	pcParameter1[ xParameter1StringLength ] = 0x00;



	uint32_t u32date = atoi(pcParameter1);
	uint32_t u32time = atoi(pcParameter2);

	uint8_t u8day = u32date/10000;
	uint8_t u8month = (u32date - u8day*10000)/100;
	uint16_t u16year = 2000 + u32date -  u8day*10000 - u8month * 100;

	uint8_t u8hour = u32time/10000;
	uint8_t u8minute = (u32time - u8hour*10000)/100;
	uint16_t u8second = u32time -  u8hour*10000 - u8minute * 100;

	osMutexAcquire(I2CMutexHandle, 100);
	DS1307setDateTime(u16year, u8month, u8day, u8hour, u8minute, u8second);
	osMutexRelease(I2CMutexHandle);

	sprintf(buff, ">>clk set to: %2u/%2u/%2u %2u:%2u:%2u\r\n",u8day,u8month,u16year,u8hour, u8minute, u8second);
	strcat(pcWriteBuffer,buff);
	return pdFALSE;
}
static const CLI_Command_Definition_t xclk =
{
	"rtc", /* The command string to type. */
	"rtc <ddmmyy> <hhmmss>:\r\n set the rtc to the indicated date and time\r\n\r\n",
	CmdClock, /* The function to run. */
	2 /* 2 parameters are expected. */
};
/******************************************************************************************************/
/******************************************************************************************************/
//analogic
/******************************************************************************************************/
/******************************************************************************************************/
//files
/******************************************************************************************************/
/******************************************************************************************************/
//FreeRTOS
/*
 * Implements the run-time-stats command.
 */
static BaseType_t prvTaskStatsCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString );

static BaseType_t prvTaskStatsCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
{
const char *const pcHeader = "Task          State  Priority  Stack	#\r\n************************************************\r\n";

	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	( void ) pcCommandString;
	( void ) xWriteBufferLen;
	configASSERT( pcWriteBuffer );

	/* Generate a table of task stats. */
	strcpy( pcWriteBuffer, pcHeader );
	vTaskList( pcWriteBuffer + strlen( pcHeader ) );

	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}

/* Structure that defines the "task-stats" command line command.  This generates
a table that gives information on each task in the system. */
static const CLI_Command_Definition_t xTaskStats =
{
	"task-stats", /* The command string to type. */
	"task-stats:\r\n Displays a table showing the state of each FreeRTOS task\r\n\r\n",
	prvTaskStatsCommand, /* The function to run. */
	0 /* No parameters are expected. */
};
/******************************************************************************************************/

void vRegisterCLICommands(void)
{
    FreeRTOS_CLIRegisterCommand(&xCmdOK);
    FreeRTOS_CLIRegisterCommand(&xCmdLed);
    FreeRTOS_CLIRegisterCommand(&xCmdBuzzer);
    FreeRTOS_CLIRegisterCommand(&xTaskStats);
    FreeRTOS_CLIRegisterCommand(&xclk);
    FreeRTOS_CLIRegisterCommand(&xCmdServo);
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	HAL_UART_Receive_IT(&huart2, &cRxedChar, 1); //You need to toggle a breakpoint on this line!
}
